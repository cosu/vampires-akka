<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StatsProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">server</a> &gt; <a href="index.source.html" class="el_package">ro.cosu.vampires.server.actors</a> &gt; <span class="el_source">StatsProcessor.java</span></div><h1>StatsProcessor.java</h1><pre class="source lang-java linenums">/*
 *
 *  * The MIT License (MIT)
 *  * Copyright © 2016 Cosmin Dumitru, http://cosu.ro &lt;cosu@cosu.ro&gt;
 *  *
 *  * Permission is hereby granted, free of charge, to any person obtaining a copy
 *  * of this software and associated documentation files (the “Software”), to deal
 *  * in the Software without restriction, including without limitation the rights
 *  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  * copies of the Software, and to permit persons to whom the Software is
 *  * furnished to do so, subject to the following conditions:
 *  *
 *  * The above copyright notice and this permission notice shall be included in
 *  * all copies or substantial portions of the Software.
 *  *
 *  * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  * THE SOFTWARE.
 *  *
 *
 */

package ro.cosu.vampires.server.actors;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import com.codahale.metrics.Counter;
import com.codahale.metrics.Gauge;
import com.codahale.metrics.Histogram;
import com.codahale.metrics.Meter;
import com.codahale.metrics.MetricRegistry;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

import ro.cosu.vampires.server.resources.Resource;
import ro.cosu.vampires.server.resources.ResourceInfo;
import ro.cosu.vampires.server.values.ClientInfo;
import ro.cosu.vampires.server.values.jobs.Job;
import ro.cosu.vampires.server.values.jobs.metrics.CounterSnapshot;
import ro.cosu.vampires.server.values.jobs.metrics.HistogramSnapshot;
import ro.cosu.vampires.server.values.jobs.metrics.MeterSnapshot;
import ro.cosu.vampires.server.values.jobs.metrics.Stats;
import ro.cosu.vampires.server.values.jobs.metrics.ValueSnapshot;

<span class="fc" id="L59">public class StatsProcessor {</span>

<span class="fc" id="L61">    private static final Logger LOG = LoggerFactory.getLogger(StatsProcessor.class);</span>

<span class="fc" id="L63">    private MetricRegistry metricRegistry = new MetricRegistry();</span>

<span class="fc" id="L65">    private Map&lt;String, LocalDateTime&gt; clientsCreatedAt = Maps.newHashMap();</span>
<span class="fc" id="L66">    private Map&lt;String, ClientInfo&gt; clientsInfo = Maps.newHashMap();</span>
<span class="fc" id="L67">    private Map&lt;String, ResourceInfo&gt; resourcesInfo = Maps.newHashMap();</span>

<span class="fc" id="L69">    private Stats latestStats = Stats.empty();</span>

    public void flush() {
<span class="fc" id="L72">        Map&lt;String, HistogramSnapshot&gt; histograms = Maps.newHashMap();</span>
<span class="fc" id="L73">        Map&lt;String, MeterSnapshot&gt; meters = Maps.newHashMap();</span>
<span class="fc" id="L74">        Map&lt;String, CounterSnapshot&gt; counters = Maps.newHashMap();</span>
<span class="fc" id="L75">        Map&lt;String, ValueSnapshot&gt; values = Maps.newHashMap();</span>


<span class="fc" id="L78">        metricRegistry.getHistograms().entrySet().forEach(m -&gt; {</span>
<span class="fc" id="L79">            String name = m.getKey();</span>
<span class="fc" id="L80">            Histogram value = m.getValue();</span>
<span class="fc" id="L81">            histograms.put(name, HistogramSnapshot.fromHistogram(name, value));</span>
<span class="fc" id="L82">        });</span>

<span class="fc" id="L84">        metricRegistry.getMeters().entrySet().forEach(m -&gt; {</span>
<span class="fc" id="L85">            String name = m.getKey();</span>
<span class="fc" id="L86">            Meter value = m.getValue();</span>
<span class="fc" id="L87">            meters.put(name, MeterSnapshot.fromMeter(name, value));</span>
<span class="fc" id="L88">        });</span>

<span class="fc" id="L90">        metricRegistry.getCounters().entrySet().forEach(m -&gt; {</span>
<span class="fc" id="L91">            String name = m.getKey();</span>
<span class="fc" id="L92">            Counter value = m.getValue();</span>
<span class="fc" id="L93">            counters.put(name, CounterSnapshot.fromCounter(name, value));</span>
<span class="fc" id="L94">        });</span>

<span class="fc" id="L96">        metricRegistry.getGauges().entrySet().forEach(m -&gt; {</span>
<span class="fc" id="L97">            String name = m.getKey();</span>
<span class="fc" id="L98">            Gauge value = m.getValue();</span>
<span class="fc" id="L99">            values.put(name, ValueSnapshot.fromGauge(name, value));</span>
<span class="fc" id="L100">        });</span>

<span class="fc" id="L102">        latestStats = Stats.builder()</span>
<span class="fc" id="L103">                .counters(ImmutableMap.copyOf(counters))</span>
<span class="fc" id="L104">                .values(ImmutableMap.copyOf(values))</span>
<span class="fc" id="L105">                .meters(ImmutableMap.copyOf(meters))</span>
<span class="fc" id="L106">                .resources(ImmutableList.copyOf(resourcesInfo.values()))</span>
<span class="fc" id="L107">                .histograms(ImmutableMap.copyOf(histograms)).build();</span>
<span class="fc" id="L108">    }</span>

    public Stats getStats() {
<span class="fc" id="L111">        return latestStats;</span>
    }

    public void process(ClientInfo message) {
<span class="fc" id="L115">        String from = message.id();</span>
<span class="fc" id="L116">        clientsInfo.put(from, message);</span>
<span class="fc" id="L117">    }</span>

    public void process(ResourceInfo message) {
<span class="fc" id="L120">        String from = message.parameters().id();</span>

<span class="fc" id="L122">        clientsCreatedAt.put(from, message.createdAt());</span>
<span class="fc" id="L123">        boolean seenBefore = resourcesInfo.containsKey(from);</span>
<span class="fc" id="L124">        resourcesInfo.put(from, message);</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (seenBefore) return;</span>

        // node count
<span class="fc bfc" id="L128" title="All 2 branches covered.">        for (String key : getKeysForMetric(from, &quot;resources&quot;)) {</span>
<span class="fc" id="L129">            metricRegistry.counter(key).inc();</span>
<span class="fc" id="L130">        }</span>

<span class="fc" id="L132">        List&lt;String&gt; costMetricKeys = getKeysForMetric(from, &quot;cost&quot;);</span>
        // remove the client key from the keys. this will provide the actual value

<span class="fc" id="L135">        String clientCostMetricKey = costMetricKeys.get(0);</span>

        // register a cost gauge for this client
<span class="fc" id="L138">        metricRegistry.register(clientCostMetricKey, (Gauge&lt;Double&gt;) () -&gt; getCostForClient(from));</span>

        // cost gauges for the rest

<span class="fc bfc" id="L142" title="All 2 branches covered.">        for (String key : costMetricKeys) {</span>
            // key not registered yet
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (!metricRegistry.getGauges().containsKey(key)) {</span>

<span class="fc" id="L146">                metricRegistry.register(key, (Gauge&lt;Double&gt;) () -&gt;</span>
                        // get all the sibling gauges (but not the current gauge - nudge it with a :)
<span class="fc bfc" id="L148" title="All 2 branches covered.">                        metricRegistry.getGauges((name, metric) -&gt; name.startsWith(key + &quot;:&quot;) &amp;&amp;</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">                                name.split(&quot;:&quot;).length - key.split(&quot;:&quot;).length == 1)</span>
<span class="fc" id="L150">                                .values().stream()</span>
<span class="fc" id="L151">                                .mapToDouble(g -&gt; (Double) g.getValue())</span>
<span class="fc" id="L152">                                .sum());</span>
            }
<span class="fc" id="L154">        }</span>
<span class="fc" id="L155">    }</span>

    public void process(Job job) {

<span class="fc" id="L159">        String from = job.from();</span>
        // do not process jobs from strangers
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (!resourcesInfo.containsKey(from)) {</span>
<span class="fc" id="L162">            LOG.warn(&quot;client {} not registered. skipping processing&quot;, from);</span>
<span class="fc" id="L163">            return;</span>
        }

<span class="pc" id="L166">        job.hostMetrics().metrics().stream().flatMap(m -&gt; m.values().entrySet().stream())</span>
<span class="fc" id="L167">                .forEach(e -&gt; {</span>
                    // converts doubles to longs
<span class="nc" id="L169">                    Double value = e.getValue();</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                    if (value &lt; 100) {</span>
<span class="nc" id="L171">                        value = 1000. * value;</span>
                    }
<span class="nc" id="L173">                    long rounded = Math.round(value);</span>
<span class="nc" id="L174">                    String key = e.getKey();</span>
<span class="nc" id="L175">                    updateMetric(from, key, rounded);</span>
<span class="nc" id="L176">                });</span>

<span class="fc" id="L178">        updateMetric(from, &quot;duration&quot;, job.result().duration());</span>
<span class="fc" id="L179">        updateMetric(from, &quot;job&quot;, 0);</span>

<span class="fc" id="L181">    }</span>

    private void updateMetric(String clientId, String metric, long value) {

<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (String key : getKeysForMetric(clientId, metric)) {</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">            if (&quot;job&quot;.equals(metric)) {</span>
<span class="fc" id="L187">                metricRegistry.meter(key).mark();</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">            } else if (metric.contains(&quot;bytes&quot;)) {</span>
<span class="nc" id="L189">                metricRegistry.counter(key).inc(value);</span>
            } else {
<span class="fc" id="L191">                metricRegistry.histogram(key).update(value);</span>
            }
<span class="fc" id="L193">        }</span>
<span class="fc" id="L194">    }</span>

    private double getCostForClient(String id) {

<span class="fc" id="L198">        long billedHours = getDurationForClient(id).toHours() + 1;</span>
<span class="fc" id="L199">        double cost = resourcesInfo.get(id).parameters().cost();</span>
<span class="fc" id="L200">        return billedHours * cost;</span>
    }

    private Duration getDurationForClient(String id) {
<span class="fc" id="L204">        LocalDateTime createdAt = clientsCreatedAt.get(id);</span>
<span class="fc" id="L205">        LocalDateTime now = LocalDateTime.now();</span>

<span class="fc" id="L207">        return Duration.between(createdAt, now);</span>
    }

    private String getInstanceType(String from) {
<span class="fc" id="L211">        return resourcesInfo.get(from).parameters().instanceType();</span>
    }

    private Resource.ProviderType getProviderType(String from) {
<span class="fc" id="L215">        return resourcesInfo.get(from).parameters().providerType();</span>
    }

    private List&lt;String&gt; getKeysForMetric(String clientId, String metric) {

<span class="fc" id="L220">        String instanceType = getInstanceType(clientId);</span>
<span class="fc" id="L221">        Resource.ProviderType providerType = getProviderType(clientId);</span>

        // return the keys in reverse order: most specific (longest) first
<span class="fc" id="L224">        return Lists.reverse(Lists.newArrayList(metric,</span>
<span class="fc" id="L225">                Joiner.on(&quot;:&quot;).join(metric, providerType),</span>
<span class="fc" id="L226">                Joiner.on(&quot;:&quot;).join(metric, providerType, instanceType),</span>
<span class="fc" id="L227">                Joiner.on(&quot;:&quot;).join(metric, providerType, instanceType, clientId)));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>